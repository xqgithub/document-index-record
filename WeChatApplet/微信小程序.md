<h1 style="text-align:center">微信小程序课程笔记 </h1>

## 小程序的适用性

### 一.什么是微信小程序？

是一种不需要下载安装即可适用的应用，它实现了应用的”触手可及“的梦想，用户扫一扫或搜一下即可打开应用。微信小程序是一种寄生于微信，跨平台的应用，开发成本低，开发流程简单。

### 二.微信小程序适合做什么样的应用？

1. 业务逻辑简单
2. 使用频率低
3. 性能要求低

#### 适用

1. 购票（中铁12306）
2. 查询（新冠）
3. 缴费
4. 金融（查询余额）
5. 保险（查询余额）
6. 美团（点餐功能）

#### 不适用

1. 手游
2. 直播
3. 购物
4. 金融
5. 保险
6. 美团

## 开发文档及开发工具

### 一.开发文档

[微信官方文档·小程序](https://developers.weixin.qq.com/miniprogram/dev/framework/)

### 二.开发工具

1. phpstudy集成环境安装：https://www.xp.cn/ 根据系统选择对应的程序下载安装
2. HBuilder代码工具：https://www.dcloud.io/  根据系统选择对应的程序下载安装
3. 微信开发者工具：http://developers.weixin.qq.com/miniprogram/dev/devtools/download.html  开发文档--工具--微信开发者工具 根据系统选择对应的程序下载安装

## 小程序知识储备

### 一.开发需要的基础

1. html,css,JavaScript  必须会
2. php,mysql 了解

### 二.微信小程序开发和web开发的区别

1. 微信小程序使用数据绑定方式（数据优先），实现页面中数据的加载。
2. 数据一旦有变化，页面重新渲染。类似于vue.js框架。
3. 微信小程序不可以使用JavaScript组件库，没有windows的对象和document对象。应使用原生js。
4. ES6,ES7,ES8...统称为ES6规范



★★★ 微信小程序大量使用了ES6规范的JavaScript代码 ★★★

## ES6规范

### 一.变量声明

1. var声明的变量
   - 有变量提升
   - 可以重复声明
   - 可以先声明，再赋值
   - 可以修改值
   - 可以跨块访问，不可以跨函数访问
2. let声明的变量
   - 没有变量提升
   - 不可以重复声明
   - 可以先声明，再赋值
   - 可以修改值
   - 不可以跨块访问，不可以跨函数访问
3. const声明的变量
   - 没有变量提升
   - 不可以重复声明
   - 不可以先声明，再赋值，声明的时候必须赋值
   - 不可以直接修改值，可以修改里面的内容，通常用户声明常量
   - 不可以跨块访问，不可以跨函数访问

### 二.变量的作用域

1. 全局作用域
2. 函数作用域
3. 块作用域
   - ES6中新增加的
   - 块作用域由{ }包括

### 三.模板字符串

1. 模板字符串使用反引号来代替普通字符串中的双引号和单引号。
2. 模板字符串包含特定语法${expression}的占位符

```javascript
			const obj = {
				tbname: 'news',
				classid: '1',
				id: '5'
			}
			const url = `www.51zxw.net?\`tbname=${obj.tbname}&classid=${obj.classid}&id=${obj.id}`;
			document.write(url)
```



### 四.函数参数默认值

```javascript
			function fun2(a = 1, b = 2, c = 3) {
				return a + b + c;
			}
			// document.write(fun2(5,6))

			function fun3(a = 1, b = 2, c = ride(2)) {
				return a + b + c;
			}

			function ride(val) {
				return val * 5;
			}
			document.write(fun3(5, 6))
```



### 五.剩余运算符

1. 定义：将一个不定数量的参数表示成一个数组，...参数名
2. 剩余的参数会保存为一个数组

```
function add(num, ...arr)
```

### 六.扩展运算符

1. 将数组或对象分割（展开），各个项作为独立的个体，...数组名

```javascript
			const obj1 = {
				id: 6,
				name: '张三'
			}
			const obj2 = {
				age: 18,
				sex: '男'
			}
			let obj3={...obj1,...obj2}
			console.log(obj3)
```



### 七.解构赋值

1. 解构赋值是对赋值运算符的扩展
2. 是一种对数组或者对象进行模式匹配，然后对其中的变量进行赋值
3. 在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取

```javascript
			let obj = {
				name: '张三',
				age: '18',
				sex: '男'
			}

			let {
				name,
				age,
				sex
			} = obj
			console.log(name, age, sex);
```

```javascript
			 let arr = [1, 2, 3, 4, 5];
			 let [a, b, c, d, e] = arr;
			 console.log(a, b, c, d, e);
```

### 八.对象的简写

1. 当属性名和属性值一样的时候，可以只写一个
2. 对象中的方法中的“：function"可以省略不写

```javascript
			const name = '张三',
				age = 18,
				sex = '男';
			//es6===========================================
			const obj = {
				name,
				age,
				xb: sex,
				getName() {
					return this.name;
				}
			}

			console.log(obj)
```

### 九.箭头函数

1. 语法：将原函数的“function"关键字删掉。并使用”=>“连接参数列表和函数体

2. 多个参数写法

   ```javascript
   			 let add = (a, b) => {
   			 	return a + b;
   			 }
   ```

3. 一个参数写法

   ```javascript
   			let add = a => {
   				return a + 10;
   			}
   ```

4. 没有参数写法

   ```javascript
   			let add = () => {
   				return 10;
   			}
   ```

5. 表达式写法

   ```javascript
   			// let add = (a, b) => a + b;
   			// let add = a => a + 10;
   			// let add = () => 10;
   			// let add = () => [1, 2, 3];
   			let add = () => ({
   				name: '张三',
   				age: 18,
   				sex: '男'
   			})
   ```

### 十.箭头函数this指向

1. 箭头函数中的this指向了<font color="#dd0000">定义时所在的对象</font>，不是调用时所在的对象

1. 普通函数中的this指向的是<font color="#dd0000">当前调用该方法的对象</font>

   ```javascript
   			let obj = {
   				name: '张三',
   				age: 18,
   				fun: () => {
   					//该this指向的是window
   					console.log(this)
   				}
   			}
   
   			obj.fun()
   ```

### 十一.promise对象

1. ES6中引入的异步操作解决方案

2. 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数

3. 是一个构造函数

   ```javascript
   //接收一个函数作为参数，函数可以有一个或者两个形参resolve(成功)，reject(失败)
   			const pA = new Promise((resolve, reject) => {
   				setTimeout(() => {
   					// let data = '从服务器返回了数据';
   					// resolve(data);
   
   					let err = '从服务器返回了数据,失败'
   					reject(err);
   				}, 2000)
   			})
   			
   			
   			pA.then(res => {
   				//promise对象中的then方法用于指定promise状态为成功时的函数回调
   				console.log(res);
   			}).catch(err => {
   				//promise对象中的catch方法用于指定promise状态为失败时的函数回调
   				console.log(err);
   			})
   ```


### 十二.async关键字

1. async关键字放到函数前面，用于表达函数是一个异步函数

2. async返回的始终是Promise对象，用then方法获取结果

   ```javascript
   			const hello = async () => {
   				return 'hello world';
   			}
   			hello().then(res => {
   				console.log(res)
   			})
   ```


### 十三.await关键字

1. await关键字只能放到<font color="#dd0000">async</font>函数里

2. 等待异步操作执行完毕，把值拿到，才会执行后面的代码

   ```javascript
   			const cf = num => {
   				return new Promise((resolve) => {
   					setTimeout(() => {
   						resolve(num * 2);
   					}, 2000)
   				})
   			}
   
   			const jf = async () => {
   				let a = await cf(1);
   				let b = await cf(2);
   				return a + b;
   			}
   
   			jf().then(res => {
   				console.log(res)
   			})
   ```

3. try/catch 语句用于处理代码中可能出现的错误信息

   ```javascript
   			const cf = num => {
   				return new Promise((resolve) => {
   					setTimeout(() => {
   						resolve(num * 2);
   					}, 2000)
   				})
   			}
   
   			const jf = async (x, y) => {
   
   				try {
   					let a = await cf(x);
   					let b = await cf(y);
   					return a + b;
   				} catch (e) {
   					//TODO handle the exception
   					console.log(e.message)
   				}
   			}
   
   			jf(1, 2).then(res => {
   				console.log(res)
   			})
   ```

## ES6的模块化

### 一.模块化的由来

1. 在之前的javascript中是没有模块化概念的。如果要进行模块化操作，需要引入第三方的类库。
2. 随着技术的发展，前后端分离，前端的业务变的越来越复杂化。到<font color="#dd0000">ES6带来了模块化，才让javascript第一次支持了module</font>

### 二.模块化的使用

ES6的模块化分为导出（export）与导入（import）

```javascript
//module.js 工具脚本

//日期时间处理函数
const formatTime = date => {
	const year = date.getFullYear()
	const month = date.getMonth() + 1
	const day = date.getDate()

	return `${[year,month,day].map(formatNumber).join('-')}`
}

const formatNumber = n => {
	n = n.toString()
	return n[1] ? n : `0${n}`
}

const uname = "小张";


export default {
	formatTime,
	uname
}
```

```javascript
			import obj from './module.js';

			console.log(obj.formatTime(new Date()))
			console.log(obj.uname)
```

## ★★★创建一个小程序

### 一.项目结构

pages/................................... 页面目录

- index/................................ index页面
  - index.js........................... index页面逻辑
  - index.json......................... index页面配置
  - index.wxml......................... index页面结构
  - index.wxss......................... index页面样式
- logs/.................................  logs页面
  - logs.js............................... logs页面逻辑
  - logs.json............................. logs页面配置 
  - logs.wxml............................. logs页面机构  
  - logs.wxss............................. logs页面样式
- utils/................................... 工具脚本目录
  - util.js............................... 工具脚本
- .eslintrc.js............................. 代码检测
- app.js.................................. 应用程序逻辑，创建应用程序实例对象
- app.json................................ 应用程序配置
- app.wxss................................ 应用程序公共样式
- project.config.json..................... 项目配置文件
- sitemap.json............................ 配置小程序及其页面是否允许被微信索引

### 二.小程序中文件说明

#### 1. app.js

- 应用程序逻辑，创建应用程序实例对象
- APP函数是一个全局函数，用来创建一个应用程序实例对象
- 每个应用程序都有它的生命周期

#### 2. app.json

- 应用程序配置

- pages 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 `.json`, `.js`, `.wxml`, `.wxss` 四个文件进行处理。

  未指定 `entryPagePath` 时，数组的第一项代表小程序的初始页面（首页)

- window 用于设置小程序的状态栏、导航条、标题、窗口背景色。

#### 3. app.wxss

- 整个应用程序中的公共样式，全局样式
- 相当于css,扩展了尺寸单位(rpx响应式像素)
- 微信小程序中大量使用了flex布局

#### 4. utils 

- 工具脚本
- util.js工具脚本，可以将一些公共的代码抽离出来成为一个单独的js文件，作为一个模块；所以当你在util.js里面封装的方法想要在外部使用的话，必须通过module.exports或者exports对外暴露
- 如何再需要使用这些模块的文件中使用：使用require()将公共代码引入

#### 5. pages

- 页面目录
- 一个小程序的页面是由4个文件组成，描述页面的四个文件必须具有相同的路径与文件名
  1. 页面.js
     - Page()也是一个全局函数，用来创建页面对象(注册小程序中的一个页面)
     - 接受一个Objectct类型参数，页面的初始数据、生命周期函数等
  2. 页面.wxml: 页面结构
     - 相当于xml+事件系统+模板引擎
     - 微信小程序中标签必须要关闭
  3. 页面.wxss： 页面样式和css样式一样的用法
  4. 页面.json: 页面的配置文件
     - 对本页面的窗口表现进行配置。页面中的配置项在当前页面会覆盖app.json中的窗口配置项

### 三.本地网组

本地网组目地：让手机能访问本地服务器上的资源

1. 本地安装服务器集成环境
2. 需要访问的设备和安装服务器 集成环境的设备，处在同一个网段
3. 点击网络，查看本地连接详细信息，查看IPV4地址（如：192.168.2.77，手动指定）
4. 通过IPV4地址，可访问到WWW目录，也可以将IPV4地址设置为指定目录的域名

### 四.小程序界面

#### 1. view组件和text组件

- 容器 div=view，具有块级元素的特点
- 文本 span=text,具有行级元素的特点

#### 2. 图片引入

- 图片 img=image,具有行内块级元素的特点

- image不设置宽高时，有默认的默认 宽=320 高=240

- 引入图片的两种方式：

  1. <image/>标签

     ```javascript
     <image style="width: 100px;height: 100px;" src="/images/icon/guanguo.png"></image>
     ```

  2. 背景图

     - ```javascript
       <view style="height:300px;width: 300px;background: url('/images/indexBackground.jpg') no-repeat 0 0/100% 100%"></view>
       ```
       
     - 背景图片在行内样式时是可以加载本地图片，<font color="#dd0000">在wxss中只能加载网路图片</font>



#### 3.rpx自适应尺寸单位

1. wxss相当于css,用来书写页面样式
   - 可以在组件头中书写行内样式，也可以在wxss中书写样式(<font color="#dd0000">自动引入</font>)
2. rpx：自适应屏幕宽度尺寸。规定屏幕宽度为750份，每份为1rpx
3. 在iPhone6上面，屏幕宽度为375px，共有750个屋里像素，1rpx=0.5px=1物理像素

#### 4.弹性布局

1. 任何容器都可以指定为Flex布局 ，任何子组件都可以设定宽高
2. 设定为flex布局以后，子元素的float、clear、vertical-align 属性将失效
3. 容器属性
   - flex-direction：
     - 属性决定主轴的方向（即项目的排列方向）
     - row | row-reverse | column | column-reverse
   - flex-wrap
     - 项目都排在一条线（又称"轴线"）上，如果一条轴线排不下，如何换行
     - nowrap | wrap | wrap-reverse
   - flex-flow
     - 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
   - justify-content
     - 属性定义了项目在主轴上的对齐方式
     - flex-start | flex-end | center | space-between | space-around
   - align-items
     - 属性定义项目在交叉轴上如何对齐
     - flex-start | flex-end | center | baseline | stretch
   - align-content
     - 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
     - flex-start | flex-end | center | space-between | space-around | stretch
4. 项目属性
   - order属性
     - 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0
   - flex-grow
     - 属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。
     - 所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
   - flex-shrink
     - 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
     - 所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小
   - fle-basis
     - 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小
     - 它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间
   - flex
     - 属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选
   - align-self
     - 允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`

#### 5.固比模型

#### 6.首页logo区块布局

- backgroud属性
  - *[background-color](https://www.runoob.com/cssref/pr-background-color.html)*：指定要使用的背景颜色
  - *[background-position](https://www.runoob.com/cssref/pr-background-position.html)*：指定背景图像的位置
  - *[background-size](https://www.runoob.com/cssref/css3-pr-background-size.html)*：指定背景图片的大小
  - *[background-repeat](https://www.runoob.com/cssref/pr-background-repeat.html)*：指定如何重复背景图像
  - *[background-origin](https://www.runoob.com/cssref/css3-pr-background-origin.html)*：指定背景图像的定位区域
  - *[background-clip](https://www.runoob.com/cssref/css3-pr-background-clip.html)*：指定背景图像的绘画区域
  - *[background-attachment](https://www.runoob.com/cssref/pr-background-attachment.html)*:置背景图像是否固定或者随着页面的其余部分滚动。
  - *[background-image](https://www.runoob.com/cssref/pr-background-image.html)*:指定要使用的一个或多个背景图像
- 定义导航栏,只保留右上角胶囊按钮
  - 框架--小程序配置--页面配置--navigation:custom

#### 7.轮播图组件

1.组件--视图容器--swiper

```xml
        <swiper indicator-dots="true" autoplay="true" interval="3000" duration="300">
            <swiper-item>
                <image src="/images/food/ggpg.jpg"></image>
            </swiper-item>
            <swiper-item>
                <image src="/images/food/ggtd.jpg"></image>
            </swiper-item>
            <swiper-item>
                <image src="/images/food/tgdt.jpg"></image>
            </swiper-item>
        </swiper>
```

#### 8.首页导航区块布局

```xml
<view class="navbox">
    <view class="nacitem">
        <image src="/images/icon/guanguo.png"></image>
        <text>干锅</text>
    </view>
    <view class="nacitem">
        <image src="/images/icon/tangguo.png"></image>
        <text>汤锅</text>
    </view>
</view>
```

```css
.navbox {
    width: 720rpx;
    height: 200rpx;
    display: flex;
    margin: 20rpx auto;
    justify-content: space-between;
}

.nacitem {
    width: 350rpx;
    height: 200rpx;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: rgb(204, 211, 211);
    box-shadow: 2px 2px 2px 2px #cccccc;
}

.nacitem image {
    width: 140rpx;
    height: 140rpx;
}

.nacitem text {
    line-height: 60rpx;
}

```

#### 9.首页美食区快布局

```xml
<view class="food-text">
    <text>美食推荐</text>
</view>
```

```css
.food-text {
    width: 720rpx;
    height: 60rpx;
    margin: 20rpx auto 20rpx;
    line-height: 60rpx;
    color: #f79534;
    font-size: 40rpx;
    font-weight: bold;
}
```

#### 10.首页列表项布局

```xml
<view class="food-box">
    <view class="food-item">
        <image src="/images//food/ggpg.jpg"></image>
        <view class="item-r">
            <text class="title">香辣排骨干锅</text>
            <text class="small">食材主要有原味排骨，辅料：油辣椒、黄豆酱、油泼辣子、调料：蒜泥、姜末、冰糖、生抽</text>
            <view class="price-box">
                <text class="price">大158/中128/小98元</text>
                <view class="btn">详情</view>
            </view>
        </view>
    </view>
</view>
```

```css
.food-box {
    width: 720rpx;
    margin: 0 auto;
}

.food-item {
    height: 220rpx;
    padding: 0 0 20rpx;
    border-bottom: 1px solid #999;
    display: flex;
    justify-content: space-between;
}

.food-item image {
    width: 250rpx;
    height: 200rpx;
    border-radius: 20rpx;
}

.food-item .item-r {
    height: 220rpx;
    flex: 1;
    display: flex;
    flex-direction: column;
    padding-left: 20rpx;
}
.title{
    font-size: 40rpx;
    line-height: 60rpx;
}
.small{
    font-size: 28rpx;
    color: #666;
    line-height: 30rpx;
    height: 90rpx;
}
.price-box{
    height: 60rpx;
    margin-top: 10rpx;
    display: flex;
    justify-content: space-between;
}
.price{
     line-height: 60rpx;
     font-size: 28rpx;
     color:#e60303;
     font-weight: bold;
}
.btn{
    width: 120rpx;
    height: 60rpx;
    line-height: 60rpx;
    background-color: #07c160;
    text-align: center;
    color: white;
    border-radius: 10rpx;
}
```

